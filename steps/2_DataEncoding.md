# データの符号化

# コンテンツ
1. 誤り訂正レベルの選択
2. データの最小バージョンを決定する
3. モードインジケータの追加
4. 文字カウントインジケータの追加
5. 選択したモードを使用した符号化
6. 8bitのコードワードに分割し、必要に応じてパッドバイトを追加する
7. 次のステップ

## 誤り訂正レベルの選択
データをエンコードする前に誤り訂正レベルを選択する。<br>
導入で述べたように、QRコードは***リードソロモン誤り訂正符号***を使用する。<br>
このプロセスではエンコードされたエータを基に誤り訂正符号を生成する。<br>
QRコードリーダーはこれらの誤り訂正符号を使用して、データを正確に読み取れなかったことを判断することができる。<br>
また誤り訂正符号を用いてこれらの誤りを訂正することができる。<br>
誤り訂正にはL、M、Q、Hの4つのレベルが存在する。<br>

|誤り訂正レベル|誤り訂正能力|
|---|---|
|L|7%までの誤りを訂正可能|
|M|15%までの誤りを訂正可能|
|Q|25%までの誤りを訂正可能|
|H|30%までの誤りを訂正可能|

高い誤り訂正レベルはより多くのデータ容量を要求するため、QRコード自体も大きくなることに注意が必要。

## データの最小バージョンを決定する
QRコードのサイズの違いは***バージョン***と呼ばれ、利用可能な40のバージョンが存在する。<br>
最小バージョンはバージョン1で21x21ピクセル、<br>
バージョン2は25x25ピクセル、<br>
最大バージョンのバージョン40は177x177ピクセルと、ピクセルサイズが前のバージョンより4大きくなる。<br>

各バージョンはそれぞれ最大容量があり、最大容量は使用するモードに依存する。<br>
加えて誤り訂正レベルによってさらに制限される。<br>
ここに全てのバージョン、誤り訂正レベルのQRコード最大容量を記載する。<br>
https://github.com/riko-teki/QuRi-kinton/blob/main/steps/character_capacities_table.md

  1. 最小バージョンの決定方法<br>
  この時点でエンコード後の文字数をカウントし、指定されたエンコードモードと誤り訂正レベルの文字数を含めることができる最小バージョンを決定する。<br>
  例えば、***HELLO WORLD***というフレーズは11文字である。![文字数容量テーブル](https://github.com/riko-teki/QuRi-kinton/blob/main/steps/character_capacities_table.md)を見るとバージョン1のQRコードで誤り訂正レベルQを使用した場合英数字16文字を含めることができる。<br>
  つまり、バージョン1がこの文字数にとっての最小バージョンということになる。<br>
  フレーズが***HELLO THERE WORLD***のように16文字より長い場合、最小バージョンは2になる。<br>
  
  2. 上限<br>
  最も容量が大きいQRコードはバージョン40の誤り訂正レベルがLのものである。(以下40-Lの形式で記載)
  40-M、40-Q、40-Hは誤り訂正符号のためのスペースを要求するため40-Lと比較して容量が少ない。

## モードインジケータの追加
各エンコードモードにはそれを識別するための4bitモードインジケーターがある。<br>
エンコードされたデータは、その後のbitに使用するモードを指定する、適切なモードインジケーターで始まらなけらばいけない。<br>
下に各モードのモードインジケーターを示す。<br>

例えば、***HELLO WORLD***を英数字モードでエンコードする場合、モードインジケーターは***0010***となる。

|モード名|モードインジケーター|
|---|---|
|数字|0001|
|英数字|0010|
|バイト|0100|
|漢字|1000|
|ECI|0111|

## 文字カウントインジケータの追加
文字カウントインジケーターはエンコード後の文字数を表現するビット文字列である。<br>
文字カウントインジケーターはモードインジケーターの後に配置されなければならない。さらにQRバージョンに依存する特定のビット長でなければならない。<br>
基の入力テキストの文字数をカウントし、次にその数値をバイナリに変換する。<br>
文字カウントインジケーターの長さはエンコードモードと使用するQRコードのバージョンに依存する。<br>
適切な長さのバイナリ文字列を作るために、左側に0を埋め込む。<br>
次のリストは各モード、バージョンにおける文字カウントインジケーターのサイズである。<br>
例えば、***HELLO WORLD***をバージョン1、英数字モードでエンコードする場合、文字カウントインジケーターの長さは9bitでなければならない。<br>
***HELLO WORLD***の文字数は11であり、バイナリ表記にすると1011になる。<br>
9bit長にするために左側に0を埋め込み、000001011とする。ステップ3で得たモードインジケーターの後に配置すると***0010000001011***というbit文字列が得られる。

  1. バージョン、モード毎の文字カウントインジケーター長<br>
  |モード名|1\~9|10\~26|27\~40|
  |---|---|---|---|
  |数字|10bits|12bits|14bits|
  |英数字|9bits|11bits|13bits|
  |バイト|8bits|16bits|16bits|
  |漢字|8bits|10bits|12bits|

## 選択したモードを使用した符号化
以前述べたエンコードプロセスを使用してエンコードを行う。<br>
例として、***HELLO WORLD***をエンコードする場合、使用するモードは英数字モードである。<br>
この文字列を英数字モードでエンコードしたデータにモードインジケーターと文字カウントインジケーターを付与すると下記のようになる。

|モードインジケーター|文字カウントインジケーター|エンコード後データ|
|---|---|---|
|0010|000001011|01100001011 01111000110 10001011100 10110111000 1001101000 001101|

## 8bitのコードワードに分割し、必要に応じてパッドバイトを追加する
モードインジケーター、文字カウントインジケーター、データビットを組み立てビット文字列を取得した後に必要があれば0パディングを行う。<br>
なぜなら、QRコードの仕様では、ビット文字列はQRコードの総容量を完全に埋めていることを要求するためである。<br>
続くセクションではビット文字列に0またはパッドバイトを追加するプロセスを説明する。

  1. QRコードの必要ビット数を決定する<br>
  特定のQRコードにどのくらいのビット量を要求するかを決定するために、誤り訂正テーブルを参照する。<br>
  エンコードされたQRコードに仕様されているバージョンと誤り訂正レベルを検索し、***後で列名を記載***列の数値を見つける。<br>
  この数値に8をかけることで使用するバージョンに要求されるデータの総容量、誤り訂正レベルを取得することができる。<br>
  例えば、表によると1-QのQRコードは13文字を格納できる。したがって、このQRコードに要求されるビット総容量は13 * 8 = 104ビットということになる。

  2. 必要に応じて0ターミネーターを追加する<br>
  ビット文字列が要求ビットと比較して1~3bit短い場合、要求ビット数に到達するまで0を追加する。<br>
  ビット文字列が要求ビットと比較して4bit以上短い場合、最後に4個の0を追加する。<br>
  例えば、***HELLO WORLD***を1-Qでエンコードする場合、前のセクションで述べたとおり要求されるビットの総数は104である。<br>
  前のステップで記述したこのデータ文字列の長さは74ビットである。<br>
  この場合、ターミネーターは最大4bitでなければならない。<br>
  なので、文字列の右側に4つの0を追加する。<br>
  まだ要求ビットの104に対して短いがQRコードの仕様はターミネーターは最大4bitであることを要求する。<br>
  文字列が102bitの長さだった場合、ターミネータは2bitの長さになる。<br>

  |モードインジケーター|文字カウントインジケーター|エンコード後データ|ターミネーター|
  |---|---|---|---|
  |0010|000001011|01100001011 01111000110 10001011100 10110111000 10011010100 001101|0000|

  3. 長さを8の倍数にするために0を追加する<br>
  ターミネーターを追加した後、ビット文字列の長さが8の倍数ではない場合、ビット文字列の右側に0を追加し、8の倍数になるようにする。<br>
  例えば、***HELLO WORLD***という文字列にターミネーターを追加した後、ビット長は78になる。<br>
  00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 010000 <br>
  これは8の倍数ではない。6bitで終了しているため最後に0を二つ追加する。<br>
  00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 010000***00***<br>

  4. 文字列がまだ短すぎる場合、パッドバイトを追加する<br>
  ビット文字列がまだ最大容量を埋めるのに充分な長さではない場合、次のバイト列をビット文字列の最後に到達するまで追加する。<br>
  11101100 00010001<br>
  このバイト列はそれぞれ236と17と同等である。<br>
  これらはQRコードの仕様によってビット文字列が短い場合に追加することを要求される。<br>
  例えば、これまでの手順を踏むと***HELLO WORLD***という文字列は80bitになる。<br>
  1-Qに要求される容量は104bitであるため、容量を埋めるために追加しなければならないビット数は104 - 80 = 24である。<br>
  バイト数に換算すると24 / 8 = 3で3バイトとなる。したがって3つのパッドバイトをデータの終わりに追加しなければならない。
  00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 ***11101100 00010001 11101100***<br>

7. 次のステップ
このセクションでは生のデータビットを取得することができた。次のステップではデータに対して誤り訂正符号を生成する。
